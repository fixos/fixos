This directory is used to place all definitions that are aimed to be used from
the user space.
This is not common on "real" UNIX-like kernels, which generaly mix kernel and
shared kernel/user definitions in each public header and use preprocessor to
restrict user view (e.g. _KERNEL on Linux or NetBSD).

I assume the common way have interesting benefits (centralized headers, no need
to duplicate some directory trees...), but it seems a bit dirty for me.
So the rule here is : does a define, type or misc function should be known by
a user space application to understand a visible kernel interface? If the
answer is "yes", place a part of the header in this directory (at top-level
for now if it's not arch-specific or device-specific), and include the
corresponding <interface/path/header.h> in your usual kernel header.
In most case, try to have only one reference to this include file in the
rest of the kernel : using this way the other files don't have to known if
a given macro or type is shared with user space or not.

The design of FiXos user space headers may change in the future if some issues
are noticed, but until this (possible) moment, this directory is the good way!


Note : a new issue occured when trying to use interface headers when porting
an ISO C / POSIX library. Types and macros defined by FiXos headers are
conflicting with userspace definitions, and are not suitable for direct usage
(because the userspace library may need to only declare a subset of them
 in some places to be conform with a given standard).
On Linux/Glibc, the -partial- solution was to redifined almost every macro
and type with hardcoded values in Glibc...
I think a better solution may be to use a namespace for every variable and
macro that should be used by POSIX.1, like "__kernel_" for types and lower
case macros, and "__KERNEL_" for upper case macros. Eventualy, the kernel
should have an additional definition without this namespace in internal kernel
headers.
Of course, all definition that are not expected to collide to POSIX or ISO C
may be defined without namespace (e.g. specific ioctls values and types).

